import { TokenGroup, Token, TokenType, DimensionToken } from '@supernovaio/sdk-exporters';
import { CSSHelper, NamingHelper, StringCase } from '@supernovaio/export-helpers';
import { exportConfiguration } from '../index';

type TokenHandler = (token: Token, mappedTokens: Map<string, Token>, tokenGroups: TokenGroup[]) => string | null;

const tokenVariableName = (token: Token, tokenGroups: Array<TokenGroup>, withoutParent: boolean = false): string => {
  let parent;
  if (withoutParent) {
    parent = null;
  } else {
    parent = tokenGroups.find((group) => group.id === token.parentGroupId)!;
  }

  return NamingHelper.codeSafeVariableNameForToken(token, StringCase.paramCase, parent, '');
};

const addDisclaimer = (content: string): string => {
  if (exportConfiguration.generateDisclaimer) {
    return `/* This file was generated by Supernova, don't change by hand */\n${content}`;
  }

  return content;
};

export const generateContent = (
  tokens: Array<Token>,
  mappedTokens: Map<string, Token>,
  tokenGroups: Array<TokenGroup>,
) => {
  return [
    {
      fileName: '_spacing.scss',
      content: createSpacingContent(tokens, mappedTokens, tokenGroups),
    },
    {
      fileName: '_radii.scss',
      content: createRadiiContent(tokens, mappedTokens, tokenGroups),
    },
  ];
};

const tokensToCSS = (
  tokens: Token[],
  handler: TokenHandler,
  mappedTokens: Map<string, Token>,
  tokenGroups: Array<TokenGroup>,
): string => {
  return tokens
    .map((token) => handler(token, mappedTokens, tokenGroups))
    .filter(Boolean)
    .join('\n');
};

export const dimensionTokenToCSS = (
  token: Token,
  mappedTokens: Map<string, Token>,
  tokenGroups: Array<TokenGroup>,
): string | null => {
  if (token.tokenType !== TokenType.dimension) {
    return null;
  }

  const dimensionToken = token as DimensionToken;
  const name = tokenVariableName(dimensionToken, tokenGroups, true);
  const value = dimensionToken.value?.measure ?? 0; // Add default value
  const unit = CSSHelper.unitToCSS(dimensionToken.value?.unit);

  return `$${name}: ${value}${unit} !default;`;
};

export const createSpacingContent = (
  tokens: Token[],
  mappedTokens: Map<string, Token>,
  tokenGroups: Array<TokenGroup>,
) => {
  const filteredSpacingTokens = tokens.filter(
    (token) => token.tokenType === TokenType.dimension && token.origin?.name?.includes('Spacing'),
  );
  const spacingTokensToCSS = tokensToCSS(filteredSpacingTokens, dimensionTokenToCSS, mappedTokens, tokenGroups);
  const spacingObject = generateDimensionObject(filteredSpacingTokens, mappedTokens, tokenGroups);

  return addDisclaimer(`${spacingTokensToCSS}\n\n${spacingObject}`);
};

export const createRadiiContent = (
  tokens: Token[],
  mappedTokens: Map<string, Token>,
  tokenGroups: Array<TokenGroup>,
) => {
  const filteredRadiiTokens = tokens.filter(
    (token) => token.tokenType === TokenType.dimension && token.origin?.name?.includes('Radius'),
  );
  const radiiTokensToCSS = tokensToCSS(filteredRadiiTokens, dimensionTokenToCSS, mappedTokens, tokenGroups);
  const radiiObject = generateDimensionObject(filteredRadiiTokens, mappedTokens, tokenGroups);

  return addDisclaimer(`${radiiTokensToCSS}\n\n${radiiObject}`);
};

const generateObjectContent = (tokens: Array<Token>, tokenGroups: Array<TokenGroup>): string => {
  let result = '';

  tokens.forEach((token) => {
    const dimensionToken = token as DimensionToken;
    const name = tokenVariableName(dimensionToken, tokenGroups, true);
    const numericPart = name.match(/\d+/)?.[0];
    const prefix = `${token.origin?.name?.split('/')[0].toLowerCase()}-`; // Use template literal
    const nonNumericPart = name.replace(prefix, '');
    if (numericPart) {
      result += `${numericPart}: $${name},\n`;
    } else if (nonNumericPart) {
      result += `${nonNumericPart}: $${name},\n`;
    }
  });

  return result;
};

export const generateDimensionObject = (
  tokens: Array<Token>,
  mappedTokens: Map<string, Token>,
  tokenGroups: Array<TokenGroup>,
): string => {
  const [firstToken] = tokens;
  let objectName = '';
  if (firstToken && firstToken.origin?.name) {
    objectName = plural(firstToken.origin.name.split('/')[0].toLowerCase());
  }

  const objectContent = generateObjectContent(tokens, tokenGroups);

  return `$${objectName}: (\n${objectContent}) !default;`;
};

const plural = (name: string): string => {
  if (name === 'radius') {
    return 'radii';
  }

  if (name === 'spacing') {
    return 'spaces';
  }

  if (name.slice(-1) === 's') {
    return name;
  }

  return `${name}s`;
};
