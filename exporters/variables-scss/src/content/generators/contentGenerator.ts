import { Token, TokenGroup, TokenType } from '@supernovaio/sdk-exporters';
import { exportConfiguration } from '../../index';
import { generateCssFromTokens, generateCssObjectFromTokens } from './cssGenerator';

// add disclaimer to top of the content
const addDisclaimer = (content: string): string => {
  if (exportConfiguration.generateDisclaimer) {
    return `/* This file was generated by Supernova, don't change manually */\n${content}`;
  }

  return content;
};

export const generateFileContent = (
  tokens: Token[],
  mappedTokens: Map<string, Token>,
  tokenGroups: Array<TokenGroup>,
  tokenTypes: TokenType | TokenType[],
  groupNames: string | string[],
  withCssObject: boolean,
  hasParentPrefix: boolean = false,
) => {
  let cssTokens = '';
  let cssObject = '';

  // If tokenTypes or groupNames are strings, convert them to arrays
  const tokenTypesArray = Array.isArray(tokenTypes) ? tokenTypes : [tokenTypes];
  const groupNamesArray = Array.isArray(groupNames) ? groupNames : [groupNames];

  // iterate over token types and group names to filter tokens
  tokenTypesArray.forEach((tokenType) => {
    groupNamesArray.forEach((group) => {
      // filter tokens by token type and group name
      const filteredTokens = tokens.filter(
        (token) => token.tokenType === tokenType && token.origin?.name?.includes(group),
      );

      // generate css tokens
      cssTokens += generateCssFromTokens(filteredTokens, mappedTokens, tokenGroups, hasParentPrefix);
      cssTokens += '\n\n';

      // generate css object
      const tempCssObject = generateCssObjectFromTokens(filteredTokens, mappedTokens, tokenGroups, hasParentPrefix);
      if (tempCssObject !== null) {
        cssObject += tempCssObject;
      }
    });
  });

  let content = withCssObject ? `${cssTokens}${cssObject}` : cssTokens;

  // Remove extra blank lines
  content = content.replace(/\n{3,}/g, '\n\n');

  return {
    content: addDisclaimer(content),
  };
};
